/**
 * TagPathSet.java
 *
 * Created on 12.11.2011, 17:49:00 by radek
 */
package org.burgetr.segm.tagging;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import org.burgetr.segm.LogicalNode;
import org.burgetr.segm.LogicalTree;

/**
 * The set of tagged paths obtained from the tree.
 * @author radek
 */
public class TagPathSet
{
    /** The source logical tree (tagged) */
	private LogicalTree ltree;
	/** List of all tagged paths from root to leafs */
	private Vector<TaggedNodePath> nodePaths;
    /** All combinations of tags from root to all leafs (considering one node may have multiple tags) */
    private Vector<TagString> tagStrings;
	/** The unique tagged paths and their counts */
    private Map<TaggedNodePath, Integer> pathCounts;
    /** Total numbers of the tag strings */ 
    private Map<TagString, Integer> patternCounts;
    /** Total numbers of tag strings supporting the given path */
    private Map<TaggedNodePath, Integer> pathSupports;

	public TagPathSet(LogicalTree ltree)
	{
		this.ltree = ltree;
		nodePaths = new Vector<TaggedNodePath>();
		tagStrings = new Vector<TagString>();
		pathCounts = null;
		patternCounts = null;
		computePaths(ltree.getRoot());
        computePathCounts();
        computePatternCounts();
        computePathSupports();
	}
	
	public int size()
	{
	    return nodePaths.size();
	}
	
	public LogicalTree getLogicalTree()
	{
		return ltree;
	}
	
	public Vector<TaggedNodePath> getNodePaths()
	{
		return nodePaths;
	}
	
	public Vector<TagString> getTagStrings()
	{
		return tagStrings;
	}
	
    public Map<TaggedNodePath, Integer> getPathCounts()
    {
        return pathCounts;
    }
    
    public int getPathCount(TaggedNodePath path)
    {
        Integer i = pathCounts.get(path);
        return (i == null) ? 0 : i;
    }
    
    public Map<TaggedNodePath, Integer> getPathSupports()
    {
        return pathSupports;
    }
    
    /**
     * Obtains the total frequency of all the patterns generated by the specified path.
     * @param path the path to be examined
     * @return the total number of patterns in the page supporting this path 
     */
    public int getPathSupport(TaggedNodePath path)
    {
        Integer i = pathSupports.get(path);
        return (i == null) ? 0 : i;
    }
    
	public Map<TagString, Integer> getPatternCounts()
	{
		return patternCounts;
	}
	
	public int getPatternCount(TagString pattern)
	{
	    Integer i = patternCounts.get(pattern);
	    return (i == null) ? 0 : i;
	}
	
	/**
	 * Obtains the list of patterns sorted by their frequency.
	 * @return the list of patterns.
	 */
	public List<TagString> getFrequentPatterns()
	{
		List<TagString> patterns = new ArrayList<TagString>(patternCounts.keySet());
		Collections.sort(patterns, new Comparator<TagString>() {
		    public int compare(TagString s1, TagString s2) {
		        Integer c1 = patternCounts.get(s1);
		        Integer c2 = patternCounts.get(s2);
		        return c2.compareTo(c1); //sort in descending order
		    }
		});
		return patterns;
	}
	
    /**
     * Obtains the list of paths sorted by their frequency.
     * @return the list of patterns.
     */
    public List<TaggedNodePath> getFrequentPaths()
    {
        List<TaggedNodePath> paths = new ArrayList<TaggedNodePath>(pathCounts.keySet());
        Collections.sort(paths, new Comparator<TaggedNodePath>() {
            public int compare(TaggedNodePath s1, TaggedNodePath s2) {
                Integer c1 = pathCounts.get(s1);
                Integer c2 = pathCounts.get(s2);
                return c2.compareTo(c1); //sort in descending order
            }
        });
        return paths;
    }
    
    /**
     * Obtains the list of paths sorted by their frequency.
     * @return the list of patterns.
     */
    public List<TaggedNodePath> getSupportedPaths()
    {
        List<TaggedNodePath> paths = new ArrayList<TaggedNodePath>(pathSupports.keySet());
        Collections.sort(paths, new Comparator<TaggedNodePath>() {
            public int compare(TaggedNodePath s1, TaggedNodePath s2) {
                Integer c1 = pathSupports.get(s1);
                Integer c2 = pathSupports.get(s2);
                return c2.compareTo(c1); //sort in descending order
            }
        });
        return paths;
    }
    
	/**
	 * Finds the bottom-most tagged nodes in the tree and creates the tagged paths.
	 * @param root the root node of the processed subtree
	 * @return <code>true</code> if there were some tagged nodes in the subtree
	 */
	private boolean computePaths(LogicalNode root)
	{
		int tagcnt = root.getTags().size();
		//check the children
		boolean ret = false;
		for (int i = 0; i < root.getChildCount(); i++)
			ret = ret | computePaths(root.getChildNode(i));
		
		if (!ret && tagcnt > 0) //this node is tagged and has no tagged children 
		{
			TaggedNodePath path = new TaggedNodePath(root);
			if (!path.isEmpty())
			{
				nodePaths.add(path);
				addStringTags(path);
				//System.out.println("*** Node: " + root);
				//printPath(path);
			}
		}
		
		return ret || (tagcnt > 0);
	}
	
	private void addStringTags(TaggedNodePath path)
	{
		if (path != null)
		{
			TagString[] tags = path.getTagStrings();
			for (int i = 0; i < tags.length; i++)
				tagStrings.add(tags[i]);
		}
	}
	
	private void computePathCounts()
	{
		HashMap<TaggedNodePath, Integer> map = new HashMap<TaggedNodePath, Integer>(); 
		for (TaggedNodePath path : nodePaths)
		{
			Integer n = map.get(path);
			if (n == null)
				map.put(path, 1);
			else
				map.put(path, n + 1);
		}
		pathCounts = map;
	}
	
    private void computePatternCounts()
    {
        //create a map of tag strings and their counts
        HashMap<TagString, Integer> map = new HashMap<TagString, Integer>(); 
        for (TagString path : tagStrings)
        {
            Integer n = map.get(path);
            if (n == null)
                map.put(path, 1);
            else
                map.put(path, n + 1);
        }
        patternCounts = map;
    }

    /** Computes how many tag strings correspond to the given path */
    private int computePathSupport(TaggedNodePath path)
    {
    	int ret = 0;
    	for (TagString pattern : path.getTagStrings())
    		ret += getPatternCount(pattern);
    	return ret;
    }
    
    private void computePathSupports()
    {
        HashMap<TaggedNodePath, Integer> map = new HashMap<TaggedNodePath, Integer>(); 
        for (TaggedNodePath path : nodePaths)
        	map.put(path, computePathSupport(path));
        pathSupports = map;
    }
    
    //=============================================================================================================
    
    /**
     * Maps the destination tag and the path length to the occurence count. 
     * @param tag
     * @return
     */
    public Map<Pair<Tag, Integer>, Integer> getDescendantsOf(Tag tag)
    {
        final int MAX_DISTANCE = 4;
        Map<Pair<Tag, Integer>, Integer> ret = new HashMap<Pair<Tag, Integer>, Integer>();
        for (TaggedNodePath path : nodePaths)
        {
            int start = path.indexOf(tag);
            if (start >= 0)
            {
                boolean found = false;
                for (int end = start; !found && end < path.size() && end - start < MAX_DISTANCE; end++)
                {
                    Set<Tag> tags = path.elementAt(end).getTags();
                    if (!tags.isEmpty())
                    {
                        for (Tag ptag : tags)
                        {
                            if (!ptag.equals(tag))
                            {
                                found = true;
                                int len = end - start;
                                Pair<Tag, Integer> key = new Pair<Tag, Integer>(ptag, len);
                                Integer cnt = ret.get(key);
                                if (cnt == null)
                                    ret.put(key, 1);
                                else
                                    ret.put(key, cnt + 1);
                            }
                        }
                    }
                }
            }
        }
        return ret;
    }
    
    //=============================================================================================================
    
	@SuppressWarnings("unused")
    private void printPath(TaggedNodePath path)
	{
		if (path != null)
		{
			TagString[] tags = path.getTagStrings();
			for (int i = 0; i < tags.length; i++)
				System.out.println(tags[i]);
		}
		else
			System.out.println("(null)");
	}

}


